import asyncio



"""
    Ассинхоррные функции в отличии от обычных, возвращают не результат работы, а сопрограмму.
    Функцию корутины можно рассматривать как фабрику для создания объектов корутины
    Вызов функции корутины не приводит к выполнению кода, а возвращает корутину(сопрограмму)

    Сопрограмма (coroutine) — результат вызова асинхронной функции, представляющий собой выполнение этой
    функции, способное приостанавливаться.
    Корутина: корутины — это более общая форма подпрограмм. Подпрограммы имеют одну точку входа и одну точку выхода.
    А корутины поддерживают множество точек входа, выхода и возобновления их выполнения.

    Функцию(подпрограмму) можно запустить, её работа начнётся в одном месте и завершится в другом. А корутину(сопрограмму)
    можно запустить, потом — приостановить, потом — возобновить. Приостанавливать и возобновлять выполнение корутины можно
    много раз, пока её работа не будет, завершена.



    Футура (Future) - будущий результат выполнения сопрограммы. https://www.youtube.com/watch?v=2PxIoYvHra8&t
    Future - это awaitable объект. По сути обертка для корутины. По сути объект класса Future это итерируемый объект.
    Каждый раз совершает итерацию, когда его вызывают оператором await. Во второй итерации он проверает закончила ли
    корутина свою работу. Если нет, то выбрасывает исключение RuntimeError("await wasn't used with future"). Если
    да, то возвращает результат, который может быть и объектом исключения.
    Поэтому, внутри него не запускается какой то цикл, который ожидает результата выполнения сопрограммы. Хот так и
    можно подумать, когда читаешь определение футуры в различных источниках. Ожиданием и проверкой завершенности корутины
    по прежнему занимается цикл событий.

    Метод __await__ внутри класса Future:

    def __await__(self):
        if not self.done():
            self._asyncio_future_blocking = True
            yield self  # This tells Task to wait for completion.
        if not self.done():
            raise RuntimeError("await wasn't used with future")
        return self.result()  # May raise too.



    Task - наследуется от Future
"""


"""
    async with - Такой же обычный контекстный менеджер как и with. Только вместо магических методов __enter__ и __exit__,
    у него асинхронные методы async __aenter__ и async __aexit__. Поэтому внутри них можно писать операторы await.
    И если внутри того или иного метода встречается строка кода с await, то вызывающая этот менеджер корутина, отдает
    контроль управления, на время исполнения вызываемого через await объекта.

    async for - этот цикл вызывает у объекта асинхронный магический метод async __anext__. Когда внутри этого метода
    встречается вызов объекта через await, то вызывающая цикл корутина отдает контроль управления, на время его исполнения.
    После того, как awaitable объект вернет результат, корутина снова возобновляет свою работу, с того же места.
    Цикл async for получает результат вызова метода async __anext__, выполняет одну итерацию и снова вызывает метод
    асинхронного итератора async __anext__. И все выше описанное повторяется по кругу, до тех пор, пока метод
    async __anext__ не выкинет исключение StopAsyncIteration.


    https://www.youtube.com/watch?v=BmOjeVM0w1U&list=PLJcqk6mrJtxCo_KqHV2rM2_a3Z8qoE5Gk

    as_complited - https://www.youtube.com/watch?v=twL4lYCw8VE

    ensure_future - принимает сопрограмму, отдает циклу событий и возвращает объект future

    get_event_loop - возвращает цикл событий

    gather - собирает сопрограммы в один объект, который можно передать в цикл событий, из этого объекта можно получить
    результаты выполнения собранных в него сопрограмм

    run_until_complete - запускает работу цикла до тех пор, пока не завершатся все переданные циклу сопрограммы
    Может возвращать результат выполенения всех переданных в нее сопрограмм
    https://www.youtube.com/watch?v=NjO9Jnul4Mc&t=220s

    close - завершение работы цикла событий

    call_soon - помещает функцию обратного вызова(не корутину) в цикл событий, а тот вызывает ее в ближайшее время, как
    только сможет

    call_later - помещает функцию обратного вызова(не корутину) в цикл событий, а тот вызывает ее через то время, которое
    передано call_later аргументом.

    call_at - вызывает функцию обратного вызова(не корутину) не через какое то время, а в указанное время

    time - получает текущее время событийного цикла. Текущее время событийного цикла означает время, которое использует
    событийный цикл для отслеживания и планирования событий.
"""
