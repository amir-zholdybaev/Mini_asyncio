import time
from collections import deque
import heapq


class Scheduler:
    def __init__(self):
        self.ready = deque()
        self.sleeping = []
        self.current = None    # Currently executing generator
        self.sequence = 0

    def sleep(self, delay):
        deadline = time.time() + delay
        self.sequence += 1
        heapq.heappush(self.sleeping, (deadline, self.sequence, self.current))
        self.current = None  # "Disappear"
        return 100

    def new_task(self, coro):
        self.ready.append(coro)

    def run(self):
        while self.ready or self.sleeping:
            if not self.ready:
                deadline, _, coro = heapq.heappop(self.sleeping)
                delta = deadline - time.time()
                if delta > 0:
                    time.sleep(delta)
                self.ready.append(coro)

            self.current = self.ready.popleft()
            # Drive as a generator
            try:
                self.current.send(None)
                if self.current:
                    self.ready.append(self.current)
            except StopIteration:
                pass


sched = Scheduler()    # Background scheduler object


def countdown(n):
    while n > 0:
        print('Down', n)
        num = sched.sleep(4)
        yield
        n -= 1


def countup(stop):
    x = 0
    while x < stop:
        print('Up', x)
        sched.sleep(1)
        yield
        x += 1


sched.new_task(countdown(5))
sched.new_task(countup(20))
sched.run()


"""
    Этот способ сделать функции ассинхронными гораздо проще чем колбэки. Тут всего лишь нужно внутри исполняемой функции
    вызвать метод планировщика, который положит эту функцию в очередь ожидающих и вызвать оператор yield, тем самым отдать
    контроль управления из функции. Каким образом метод может положить функцию в очередь ждущих, внутри которой сам
    вызывается?

    Дело в том, что функция сначала скармливается планировщику, который перед ее вызовом кладет ее во внутреннее свойство
    self.current, которое хранит текущую исполняемую функцию. Далее планировщик вызывает эту функцию, внутри нее вызывается
    метод планировщика sleep(), который внутри себя берез функцию из свойства self.current, то есть текущую, из которой
    этот метод был вызван и кладет функцию в очередь ждущих.


    sleep - Добавляет в очередь ждущих выполнения функцию, вместе с временем ее вызова в будущем

    new_task - Добавляет функцию в очередь готовых к выполнению

    run - Вызывает все готовые к вызову генераторы
    Если таковых нет, то берет ближайший ожидающий вызова,
    ждет наступление времени его вызова и вызывает
    Повторяет эти действия до тех пор, пока есть хоть однин готовый или ожидающий генератор


    Подробнее:
    Достает все генераторы из очереди готовых и вызывает их
    Если в очереди готовых ничего нет, то достает ближайщий генератор из очереди ждущих,
    ждет наступление времени его вызова, добавляет в очередь готовых, достает оттуда, обозначает как
    текущий(вызванный, исполняемый) и вызывает
    Повторяет эти действия до тех пор, пока есть хоть однин генератор в очереди готовых или ожидающих

    Еще более подробно:

    Запускает выполнение генератора

    Запускает цикл, который выполняется пока в очереди готовых или ждущих генераторов что то есть

        Если в очереди готовых ничего нет:

            То из очереди ждущих, достает генератор, у которого самое ближайшее время вызова

            Вычисляет оставшееся до вызова время

            Если оно больше нуля, то делает паузу на это время, а после добавляет в очередь готовых

            Если оно равно или меньше нуля, то сразу добавляет в очередь готовых

        А после достает первый генератор из очереди готовых, обозначает его как
        текущий(выполняемый, кладет в свойство self.current) и вызывает, после вызова проверяет - обозначается ли вызванный
        генератор как текущий(не пусто ли свойство self.current). Если обозначается, то кладет его в конец очереди готовых,
        давая исполниться другим генераторам из очереди либо делает это для того, чтобы сразу же вызвать этот же
        генератор, в случае, если других готовых генераторов нет

        Если в очереди готовых что то есть, то достает первый генератор из очереди готовых, обозначает его как
        текущий(выполняемый, кладет в свойство self.current) и вызывает, пропуская выше описанные операции с генератором
        из очереди ждущих.
        После вызова проверяет - обозначается ли вызванный генератор как текущий(не пусто ли свойство self.current).
        Если обозначается, то кладет его в конец очереди готовых, давая исполниться другим генераторам из очереди либо
        делает это для того, чтобы сразу же вызвать этот же генератор, в случае, если других готовых генераторов нет

        Цикл начинает новую итерацию. Таким образом, цикл выполняется вызывая все готовые генераторы, которые есть в очереди.
        Каждый генератор вызывается и кладется в конец очереди по кругу, до тех пор, пока не выкинет ошибку StopIteration
        Если в очереди готовых только один генератор, то он
"""
