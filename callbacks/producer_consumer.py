import queue
import threading
import time


def producer(q, count):
    for n in range(count):
        print('Producing', n)
        q.put(n)
        time.sleep(1)

    print('Producer done')
    q.put(None)   # "Sentinel" to shut down


def consumer(q):
    while True:
        item = q.get()
        if item is None:
            break
        print('Consuming', item)
    print('Consumer done')


q = queue.Queue()   # Thread-safe queue
threading.Thread(target=producer, args=(q, 10)).start()
threading.Thread(target=consumer, args=(q,)).start()


"""
    Проблема продюсера и консюмера - это классическая проблема синхронизации между двумя или более процессами,
    которые используют общий буфер или очередь для обмена данными. Продюсер - это процесс, который генерирует
    данные и помещает их в буфер, а консюмер - это процесс, который извлекает данные из буфера и обрабатывает их.
    Эта проблема возникает, когда нужно обеспечить правильный порядок и скорость передачи данных между процессами,
    а также избежать переполнения или опустошения буфера.

    Код, который тут написан, решает проблему продюсера и консюмера с помощью потоков (threads) и очереди (queue).
    Потоки - это подпроцессы, которые могут выполняться параллельно в рамках одного процесса. Очередь - это структура
    данных, которая работает по принципу FIFO (first in, first out), то есть первый пришел - первый вышел.
    Очередь в Python поддерживает потокобезопасность (thread-safety), то есть она автоматически синхронизирует доступ
    к данным между потоками

    В коде создается два потока: один для продюсера и один для консюмера. Также создается очередь q, которая будет
    использоваться для передачи данных между ними. Продюсер генерирует числа от 0 до 9 с интервалом в 1 секунду и
    помещает их в очередь q. Когда он заканчивает генерацию, он отправляет специальное значение None в очередь,
    чтобы сигнализировать о завершении работы. Консюмер постоянно извлекает данные из очереди q и выводит их в консоль.
    Когда он получает значение None, он прекращает работу.

    Один из простых практических примеров, где может возникнуть проблема продюсера и консюмера, - это ситуация, когда
    один процесс читает данные из файла или сети и передает их другому процессу для обработки или записи. Например,
    если мы хотим скопировать большой файл с одного диска на другой, мы можем использовать два процесса: один будет
    читать данные из исходного файла и помещать их в буфер, а другой будет брать данные из буфера и записывать их в
    целевой файл. Это позволит ускорить копирование, так как процессы будут работать параллельно и не будут ждать друг
    друга. Однако, при этом нужно учитывать, что буфер имеет ограниченный размер и не может хранить бесконечное
    количество данных. Поэтому, если процесс-продюсер генерирует данные быстрее, чем процесс-консюмер их обрабатывает,
    то буфер может переполниться и произойти ошибка. Аналогично, если процесс-консюмер потребляет данные быстрее, чем
    процесс-продюсер их создает, то буфер может опустошиться и процесс-консюмер будет ожидать новых данных. Поэтому,
    для решения этой проблемы нужно использовать некоторый механизм синхронизации или координации между процессами,
    чтобы поддерживать оптимальный уровень заполнения буфера.

    В этом коде решается и проблема переполнения, и проблема опустошения буфера. Используется очередь q, которая
    имеет встроенный механизм блокировки (locking) и условных переменных (condition variables), чтобы синхронизировать
    доступ к данным между потоками. Блокировка позволяет избежать конфликтов при одновременном обращении к очереди
    разными потоками, а условные переменные позволяют потокам ждать или оповещать друг друга о наличии или отсутствии
    данных в очереди.

    Когда процесс-продюсер помещает данные в очередь q, он вызывает метод put, который проверяет, не полна ли очередь.
    Если очередь полна, то метод put блокирует поток-продюсер и ждет, пока не освободится место в очереди. Когда
    процесс-консюмер извлекает данные из очереди q, он вызывает метод get, который проверяет, не пуста ли очередь.
    Если очередь пуста, то метод get блокирует поток-консюмер и ждет, пока не появятся новые данные в очереди. Когда
    процесс-консюмер извлекает данные из очереди q, он также оповещает поток-продюсер о том, что в очереди появилось
    свободное место. Аналогично, когда процесс-продюсер помещает данные в очередь q, он также оповещает поток-консюмер
    о том, что в очереди появились новые данные.

    Таким образом, код решает проблему продюсера и консюмера с помощью потоков и очереди, которая сама заботится о
    синхронизации между потоками. Это удобный и простой способ решения этой проблемы на Python.
"""
